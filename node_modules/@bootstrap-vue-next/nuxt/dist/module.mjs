import { addComponent, defineNuxtModule, createResolver, addPlugin, addImports } from '@nuxt/kit';
import { componentsWithExternalPath, composablesWithExternalPath, directiveNames, composableNames } from 'bootstrap-vue-next';

const useComponents = () => {
  for (const [name, path] of Object.entries(componentsWithExternalPath)) {
    addComponent({
      name,
      export: name,
      filePath: `bootstrap-vue-next${path}`
    });
  }
};

const parseActiveImports = (options, values) => {
  const { all, ...others } = options;
  const valuesCopy = {};
  if (all) {
    values.forEach((el) => {
      valuesCopy[el] = all;
    });
  }
  const merge = { ...valuesCopy, ...others };
  return Object.entries(merge).filter(([name, value]) => !!value && values.includes(name)).map(([name]) => name);
};

const normalizeConfigurationValue = (option) => {
  return typeof option === "boolean" ? { all: option } : option;
};

const module = defineNuxtModule({
  meta: {
    name: "bootstrap-vue-next",
    configKey: "bootstrapVueNext",
    compatibility: {
      nuxt: ">=3.0.0",
      bridge: false
    }
  },
  defaults: {
    composables: true,
    directives: true,
    css: true,
    plugin: {}
  },
  setup(options, nuxt) {
    const { resolve } = createResolver(import.meta.url);
    nuxt.options.build.transpile.push(resolve("./runtime"));
    if (options.css === true) {
      nuxt.options.css.push("bootstrap-vue-next/dist/bootstrap-vue-next.css");
    }
    const normalizedComposableOptions = normalizeConfigurationValue(options.composables);
    const normalizedDirectiveOptions = normalizeConfigurationValue(options.directives);
    nuxt.options.vite.optimizeDeps = nuxt.options.vite.optimizeDeps || {};
    nuxt.options.vite.optimizeDeps.include = nuxt.options.vite.optimizeDeps.include || [];
    nuxt.options.vite.optimizeDeps.include.push("bootstrap-vue-next");
    addPlugin(resolve("./runtime/createBootstrap"));
    const transformAssetUrls = Object.freeze({
      BImg: ["src"]
    });
    nuxt.options.vite.vue = nuxt.options.vite.vue || {};
    nuxt.options.vite.vue.template = nuxt.options.vite.vue.template || {};
    nuxt.options.vite.vue.template.transformAssetUrls = nuxt.options.vite.vue.template.transformAssetUrls ?? {};
    if (typeof nuxt.options.vite.vue.template.transformAssetUrls !== "boolean" && !("BImg" in nuxt.options.vite.vue.template.transformAssetUrls || "b-img" in nuxt.options.vite.vue.template.transformAssetUrls)) {
      nuxt.options.vite.vue.template.transformAssetUrls = {
        ...nuxt.options.vite.vue.template.transformAssetUrls,
        ...transformAssetUrls
      };
    }
    useComponents();
    if (Object.values(normalizedDirectiveOptions).includes(true)) {
      const activeDirectives = parseActiveImports(normalizedDirectiveOptions, directiveNames);
      nuxt.options.runtimeConfig.public.bootstrapVueNext = {
        directives: activeDirectives,
        plugin: options.plugin
      };
      addPlugin(resolve("./runtime/useDirectives"));
    }
    if (Object.values(normalizedComposableOptions).includes(true)) {
      parseActiveImports(normalizedComposableOptions, composableNames).forEach((name) => {
        const from = `bootstrap-vue-next${composablesWithExternalPath[name]}`;
        addImports({
          from,
          name
        });
      });
    }
  }
});

export { module as default };
